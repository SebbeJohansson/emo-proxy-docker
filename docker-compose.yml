services:
  dnsmasq:
    image: andyshinn/dnsmasq:latest
    container_name: emo-dns
    network_mode: "host"
    cap_add:
      - NET_ADMIN
    volumes:
      - ./dnsmasq.conf:/etc/dnsmasq.conf
    restart: unless-stopped

  nginx:
    image: nginx:alpine
    network_mode: "host"
    volumes:
      - ./nginx/default.conf:/etc/nginx/conf.d/default.conf
      - ./nginx/ssl:/etc/nginx/ssl
    restart: unless-stopped

  mitmproxy: # Send emo through mitmproxy to the emo proxy.
    image: mitmproxy/mitmproxy
    container_name: mitm-proxy
    network_mode: "host"
    entrypoint: mitmweb
    # mode reverse:http://localhost:8080 tells mitmproxy to forward all
    # incoming traffic to your Go app.
    command: >
      --mode reverse:http://localhost:8080
      --listen-port 8082
      --web-port 8081
      --web-host 0.0.0.0
      --set web_password=emo
    restart: unless-stopped

  # mitmproxy: # Send emo through mitmproxy directly to living.ai, bypassing the emo proxy.
  #   image: mitmproxy/mitmproxy
  #   container_name: mitm-proxy
  #   network_mode: "host"
  #   entrypoint: mitmweb
  #   command: >
  #     --mode reverse:https://api.living.ai
  #     --listen-port 8082
  #     --web-port 8081
  #     --web-host 0.0.0.0
  #     --set keep_host_header=true
  #     --set ssl_verify_upstream=false
  #     --set web_password=emo
  #   restart: unless-stopped

  # emo-proxy: # Start emo from docker instead of through console.
  #   image: golang:1.21-alpine
  #   network_mode: "host"
  #   volumes:
  #     - ../Documents/emo/Proxy:/app
  #   working_dir: /app
  #   # The proxy now listens on 8080 as plain HTTP
  #   command: go run emoProxy.go
  #   restart: unless-stopped